# -*- coding: utf-8 -*-
"""IEP-IAA-PP_u3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JKtRLRAJ4fpYDb0BEK7iA08YFPlN_GLd

**Resolucion de Tareas**

Unidad 3, Python programming

12/14/2024

*Realizado por Andres Felipe Lopez, candidato a Master en inteligencia artificial IEP 2025*

# **Ejercicio 1 flota de camiones**

Tenemos una empresa que gestiona una flota de camiones. Almacenamos la siguiente información de nuestros vehículos en formato diccionario, donde la clave es el identificador del vehículo y el valor una lista que contiene la información del modelo, el año y la matrícula. Los tipos de datos serán los siguientes:

  • id --> numérico
  • Modelo del vehículo --> cadena
  • Año de compra --> numérico (int)
  • Matrícula --> cadena Trabajaremos con el siguiente diccionario como punto de partida:

camiones = {
  201: ["Renault",2020,"3541BW4"],     202: ["Mercedes",2018, "9834HJ1"],     203: ["Volvo", 2005, "6712CK9"],     204: ["BMW",2023, "1289LM2"]

Las matrículas siempre acaban en una letra pero ha habido un problema en el almacenamiento de los datos y la matrícula se ha quedado corrupta, la última letra de la misma se ha cambiado por un número. Nos piden que solventemos este error.  Para ello vamos a calcular nosotros la última letra de cada matrícula de la siguiente manera: tomamos el número completo de hasta 4 cifras de nuestra matrícula, lo dividimos entre 20 y nos quedamos con el resto de dicha división, o dicho de otro modo, calculamos el módulo 20 de la matrícula. A cada uno de estos posibles restos le corresponde una letra, según la siguiente tabla:

Debemos seguir estos pasos para llevar a cabo la tarea:

1. Definiremos una función main() que es la que ejecutará todo el programa. Dentro de la misma generaremos un bucle que vaya recorriendo uno a uno los elementos del diccionario.

2. Dentro de ese bucle, llamaremos a dos funciones con los argumentos adecuados: GetNumber(string), y GerLetter(int)

3. La función GetNumber(), recibirá como argumento la matrícula completa con la letra errónea (en formato string ya que está en una sola variable), y nos devolverá el número separado de la letra errónea de la misma.Sólo nos devolverá el número.

4. La función GerLetter(), recibirá como argumento el número de la matrícula, y calculará la letra correcta, agregándola al número y devolviendo una cadena con la matrícula correcta. 5. Modificaremos la matrícula en el diccionario por la correcta
"""

# Diccionario inicial de camiones
camiones = {
    201: ["Renault", 2020, "3541BW4"],
    202: ["Mercedes", 2018, "9834HJ1"],
    203: ["Volvo", 2005, "6712CK9"],
    204: ["BMW", 2023, "1289LM2"]
}

# Tabla de letras para módulo 20
tabla_letras = "TRWAGMYFPDXBNJZSQVHLCKE"

def GetNumber(matricula):
    """Extrae la parte numérica de la matrícula."""
    numeric_part = ''.join(filter(str.isdigit, matricula))  # Extrae sólo los dígitos
    return int(numeric_part)

def GerLetter(numero):
    """Calcula la letra correcta basada en el módulo 20."""
    letra_index = numero % 20
    return tabla_letras[letra_index]

def main():
    for key, data in camiones.items():
        matricula = data[2]
        numero = GetNumber(matricula)
        letra_correcta = GerLetter(numero)
        matricula_correcta = f"{numero}{letra_correcta}"
        camiones[key][2] = matricula_correcta
    print("Camiones actualizados:", camiones)

main()

"""# **Ejercicio 2: Funciones Lambda**

2.1 Valores cuadrados  Escribe un programa que cree una lista (usando lambda) cuyos elementos son el cuadrado de los elementos de la lista [1,2,3,4,5,6,7,8,9,10].

2.2 Cuadrados de los números pares  Ahora escribe un programa que haga una lista (usando lambda) cuyos elementos sean el cuadrado de los números pares de la lista [1,2,3,4,5,6,7,8,9,10]

2.3 Conteo de letras Por último, escribe un programa que dada una lista palabras devuelva una lista con el número de letras de cada palabra. Usa lambda.
"""

numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
cuadrados = list(map(lambda x: x**2, numeros))
print("Cuadrados:", cuadrados)

pares = list(filter(lambda x: x % 2 == 0, numeros))
cuadrados_pares = list(map(lambda x: x**2, pares))
print("Cuadrados de números pares:", cuadrados_pares)

palabras = ["hola", "mundo", "python", "programación"]
conteo_letras = list(map(lambda palabra: len(palabra), palabras))
print("Conteo de letras:", conteo_letras)

"""# **Ejercicio 3: Sistema Bancario**

En este ejercicio se plantea modelizar, mediante la Programación Orientada a Objetos, a los clientes de un banco.

La información y los comportamientos que se quieren modelizar son los siguientes:  

• Cuando un cliente nuevo se registra en la entidad se le solicita nombre, apellidos y su fecha de nacimiento, los clientes tienen que ser mayores de 18 años y el formato de entrada de la fecha de nacimiento es una cadena YYYY/MM/DD (AÑO/MES/DIA)

• El sistema automáticamente asignará al cliente un identificador de 6 dígitos que es el identificador único del cliente en el banco.   

• Al darse de alta los clientes comienzan con un saldo en cuenta de 0€  

• Los clientes pueden aumentar (o disminuir) este saldo mediante retiradas y depósitos, no se podrá hacer una retirada si el cliente no tiene saldo disponible.

• Al cliente se le muestra un mensaje de bienvenida al banco  

• Los clientes pueden realizar transferencias entre ellos, esto implica aumentar el saldo en cuenta de uno y disminutir el saldo en cuenta del de otro.
"""

from datetime import datetime

class Cliente:
    contador_clientes = 0

    def __init__(self, nombre, apellidos, fecha_nacimiento):
        self.nombre = nombre
        self.apellidos = apellidos
        self.fecha_nacimiento = datetime.strptime(fecha_nacimiento, '%Y/%m/%d')
        self.validar_edad()
        Cliente.contador_clientes += 1
        self.id_cliente = str(Cliente.contador_clientes).zfill(6)
        self.saldo = 0.0

    def validar_edad(self):
        edad = (datetime.now() - self.fecha_nacimiento).days // 365
        if edad < 18:
            raise ValueError("El cliente debe ser mayor de 18 años.")

    def saludo(self):
        print(f"Bienvenido {self.nombre}, tu saldo actual es: {self.saldo:.2f}€")

    def deposito(self, cantidad):
        self.saldo += cantidad
        print(f"Depósito realizado. Saldo actual: {self.saldo:.2f}€")

    def retirada(self, cantidad):
        if cantidad > self.saldo:
            print("Operación no permitida. Saldo insuficiente.")
        else:
            self.saldo -= cantidad
            print(f"Retirada realizada. Saldo actual: {self.saldo:.2f}€")

    @staticmethod
    def transferencia(emisor, receptor, cantidad):
        if cantidad > emisor.saldo:
            print("Transferencia no realizada. Saldo insuficiente.")
        else:
            emisor.saldo -= cantidad
            receptor.saldo += cantidad
            print(f"Transferencia realizada. Nuevo saldo de {emisor.nombre}: {emisor.saldo:.2f}€, {receptor.nombre}: {receptor.saldo:.2f}€")

# Crear clientes y probar
try:
    cliente1 = Cliente("Juan", "Pérez", "1990/01/01")
    cliente2 = Cliente("Ana", "López", "1995/05/05")
    cliente3 = Cliente("Carlos", "Martínez", "2010/10/10")  # Error esperado
except ValueError as e:
    print(e)

cliente1.deposito(1000)
cliente1.retirada(200)
Cliente.transferencia(cliente1, cliente2, 300)
cliente1.saludo()
cliente2.saludo()

"""# **Ejercicio 4: Análisis de sentimiento**

Para irnos familiarizando con los modelos de inteligencia artificial y cómo suelen estar implementados en Python, vamos a realizar un pequeño ejercicio de análisis de sentimiento.

El análisis de sentimiento es una técnica de procesado de lenguaje natural que determina la actitud de un autor con respecto a un tema o la polaridad del texto. Es decir, si el autor expresa una opinión positiva, negativa o neutral. Para ello, vamos a utilizar un pequeño dataset de opiniones de películas.

El dataset se encuentra en el archivo opiniones.txt, cada línea del archivo contiene una opinión. Nuestro modelo de análisis de sentimiento será muy simple, vamos a contar el número de palabras positivas y negativas en cada opinión. Para ello, vamos a utilizar dos listas de palabras, una con palabras positivas y otra con palabras negativas, que se podrán ir actualizando, eliminando o añadiendo nuevas palabras.

El objetivo final es tener una función o un método en Python que reciba una cadena de texto opinión y devuelva si es positiva o negativa en base a si tiene más palabras positivas que negativas o viceversa. En caso de ser igual, la opinión será neutral. Este ejercicio se puede realizar de muchas maneras, pero se propone la siguiente guía:

1. Crear una clase AnalisisSentimiento que tenga dos listas de palabras, una para las palabras positivas y otra para las palabras negativas. Estas listas se pueden inicializar con un conjunto de palabras por defecto, por ejemplo: ["bueno", "excelente"] para las palabras positivas y ["malo", "horrible"] para las palabras negativas. Crear un método  __init__ que inicialice las listas de palabras.

2. Crear dos métodos privados _contar_positivas y _contar_negativas que reciban una cadena de texto y devuelvan el número de palabras positivas o negativas que contiene. Recuerda que el método count cuenta el número de veces que aparece una palabra en una lista, para dividir un texto en una lista de palabras se emplea el método split(' '). Ten en cuenta que hay que hacer la suma de las veces que aparece cada palabra, un list comprehension es una buena opción para esto. Por ejemplo: texto = "Hola me llamo Juan" texto.split(' ') # Devuelve ["Hola", "me", "llamo", "Juan"] texto.split(' ').count("Hola") # Devuelve 1

3. Crear un método predict que reciba una cadena de texto y devuelva si es positiva o negativa en base a si tiene más palabras positivas que negativas o viceversa. Internamente, este método debe de utilizar los métodos privados _contar_positivas y _contar_negativas. Casi todos los modelos de inteligencia artificial tienen un método predict que devuelve una predicción en base a los datos de entrada.

4. Para incluir la funcionalidad de actualizar el modelo de sentimiento, añade un método llamado fit que reciba dos listas de palabras, una con palabras positivas y otra con palabras negativas y las añada a las listas ya existentes de palabras de la clase. Casi todos los modelos de inteligencia artificial tienen un método fit que actualiza el modelo en base a nuevos datos, en este caso los nuevos datos son las nuevas palabras positivas y negativas.  El último paso sería probar el modelo con algunas opiniones. Primero crea una instancia de la clase AnalisisSentimiento y prueba a predecir si algunas opiniones son positivas o negativas. Después, actualiza el modelo con algunas palabras nuevas que pueden hacer que este mejore como *maravilloso* para positivas o pésimo para negativas y vuelve a probar con las mismas opiniones

A continuación, se dejan unas opiniones de ejemplo para probar el modelo aunque el alumno puede añadir las que desee. opiniones = [     "Me ha parecido una película muy buena",     "La música es mala, pero la fotografía es buena",     "No me ha gustado nada, no la recomiendo",     "El doblaje es pésimo y la trama es muy mala",     "Excelente película, 100% recomendable",     "La banda sonora es maravillosa y la trama me gustó" ]
"""

class AnalisisSentimiento:
    def __init__(self):
        self.palabras_positivas = ["bueno", "excelente", "maravilloso"]
        self.palabras_negativas = ["malo", "horrible", "pésimo"]

    def _contar_positivas(self, texto):
        return sum([texto.split(' ').count(palabra) for palabra in self.palabras_positivas])

    def _contar_negativas(self, texto):
        return sum([texto.split(' ').count(palabra) for palabra in self.palabras_negativas])

    def predict(self, texto):
        positivas = self._contar_positivas(texto)
        negativas = self._contar_negativas(texto)
        if positivas > negativas:
            return "Positiva"
        elif negativas > positivas:
            return "Negativa"
        else:
            return "Neutral"

    def fit(self, nuevas_positivas, nuevas_negativas):
        self.palabras_positivas.extend(nuevas_positivas)
        self.palabras_negativas.extend(nuevas_negativas)

# Probar el modelo
modelo = AnalisisSentimiento()
opiniones = [
    "Me ha parecido una película muy buena",
    "La música es mala, pero la fotografía es buena",
    "No me ha gustado nada, no la recomiendo",
    "El doblaje es pésimo y la trama es muy mala",
    "Excelente película, 100% recomendable",
    "La banda sonora es maravillosa y la trama me gustó"
]

for opinion in opiniones:
    print(f"Opinión: {opinion} -> Sentimiento: {modelo.predict(opinion)}")

modelo.fit(["fantástica"], ["terrible"])
print("Modelo actualizado con nuevas palabras.")
for opinion in opiniones:
    print(f"Opinión: {opinion} -> Sentimiento: {modelo.predict(opinion)}")